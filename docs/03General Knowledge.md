---
sidebar_position: 4
---

# 基本知识


## 标记语言

### YAML

### Markdown


## 终端

终端，也称为命令行或控制台，允许我们在计算机上完成和自动化任务，而无需使用图形用户界面。终端起源于 1950 年代至 60 年代左右，从那时起，终端一直是*所有操作系统*的一个不变特征——从台式机到隐藏在云中的服务器，再到像 Raspberry PI Zero 这样的微型计算机，甚至是手机。在大部分时候，终端、命令行是同一个意思。

### 如何学习终端命令

现在的设备多种多样，对应的终端命令也不尽相同。而且终端命令往往不能通过直接的单词缩写猜出意思，因此学习终端命令教程时需要注意：
- 足够完整
- 带有使用示例

[tldr](https://tldr.inbrowser.app/)是是社区维护的命令行工具帮助页面的集合，支持在线查询终端命令，可选择不同的平台，并支持以不同的语言显示


## 网络安全知识

### SSL/TLS协议

SSL/TLS是一种密码通信框架，他是世界上使用最广泛的密码通信方法。SSL/TLS综合运用了密码学中的对称密码，消息认证码，公钥密码，数字签名，伪随机数生成器等，可以说是密码学中的集大成者。

SSL(Secure Socket Layer)安全套接层，是1994年由Netscape公司设计的一套协议，并与1995年发布了3.0版本。

TLS(Transport Layer Security)传输层安全是IETF在SSL3.0基础上设计的协议，实际上相当于SSL的后续版本。

#### SSL/TLS的应用

![image.png](/upload/computerselfeducationroad/image-6aefdb561d584b1abb2dd26562d9adfd.png)
SSL/TLS是一个安全通信框架，上面可以承载HTTP协议或者SMTP/POP3协议等。

#### TLS协议的架构

![image.png](/upload/computerselfeducationroad/image-3998cc3751794abc965360283538446b.png)

TLS主要分为两层，底层的是TLS记录协议，主要负责使用对称密码对消息进行加密。

上层的是TLS握手协议，主要分为握手协议，密码规格变更协议和应用数据协议4个部分。

- 握手协议负责在客户端和服务器端商定密码算法和共享密钥，包括证书认证，是4个协议中最最复杂的部分。
- 密码规格变更协议负责向通信对象传达变更密码方式的信号
- 警告协议负责在发生错误的时候将错误传达给对方
- 应用数据协议负责将TLS承载的应用数据传达给通信对象的协议。

#### 握手协议

握手协议是TLS协议中非常重要的协议，通过客户端和服务器端的交互，和共享一些必要信息，从而生成共享密钥和交互证书。
![image.png](/upload/computerselfeducationroad/image-b55e0ef4d8df43e99da2aefb0ed64cb2.png)

接下来我们一步步的介绍每一步的含义：

##### client hello

client hello客户端向服务器端发送一个client hello的消息，包含下面内容：

- 可用版本号
- 当前时间
- 客户端随机数
- 会话ID
- 可用的密码套件清单
- 可用的压缩方式清单

我们之前提到了TLS其实是一套加密框架，其中的有些组件其实是可以替换的，这里可用版本号，可用的密码套件清单，可用的压缩方式清单就是向服务器询问对方支持哪些服务。

客户端随机数是一个由客户端生成的随机数，用来生成对称密钥。

##### server hello

server hello服务器端收到client hello消息后，会向客户端返回一个server hello消息，包含如下内容：

- 使用的版本号
- 当前时间
- 服务器随机数
- 会话ID
- 使用的密码套件
- 使用的压缩方式

使用的版本号，使用的密码套件，使用的压缩方式是对步骤1的回答。

服务器随机数是一个由服务器端生成的随机数，用来生成对称密钥。

##### certificate

可选步骤:certificate服务器端发送自己的证书清单，因为证书可能是层级结构的，所以处理服务器自己的证书之外，还需要发送为服务器签名的证书。客户端将会对服务器端的证书进行验证。如果是以匿名的方式通信则不需要证书。

##### ServerKeyExchange

可选步骤:ServerKeyExchange
如果第三步的证书信息不足，则可以发送ServerKeyExchange用来构建加密通道。ServerKeyExchange的内容可能包含两种形式：

- 如果选择的是RSA协议，那么传递的就是RSA构建公钥密码的参数（E，N）。我们回想一下RSA中构建公钥的公式：密文=明文^E\ mod\ N密文=明文EmodN， 只要知道了E和N，那么就知道了RSA的公钥，这里传递的就是E，N两个数字。具体内容可以参考[RSA算法详解](http://www.flydean.com/rsa/)
- 如果选择的是Diff-Hellman密钥交换协议，那么传递的就是密钥交换的参数，具体内容可以参考更加安全的密钥生成方法[Diffie-Hellman](http://www.flydean.com/diffie-hellman/)

##### CertificateRequest

可选步骤:CertificateRequest如果是在一个受限访问的环境，比如fabric中，服务器端也需要向客户端索要证书。如果并不需要客户端认证，则不需要此步骤。

##### server hello done

server hello done
服务器端发送server hello done的消息告诉客户端自己的消息结束了。

##### Certificate

可选步骤:Certificate
对步骤5的回应，客户端发送客户端证书给服务器

##### ClientKeyExchange

ClientKeyExchange还是分两种情况：

- 如果是公钥或者RSA模式情况下，客户端将根据客户端生成的随机数和服务器端生成的随机数，生成预备主密码，通过该公钥进行加密，返送给服务器端。
- 如果使用的是Diff-Hellman密钥交换协议，则客户端会发送自己这一方要生成Diff-Hellman密钥而需要公开的值。具体内容可以参考更加安全的密钥生成方法[Diffie-Hellman](http://www.flydean.com/diffie-hellman/)，这样服务器端可以根据这个公开值计算出预备主密码。

##### CertificateVerify

可选步骤:CertificateVerify客户端向服务器端证明自己是客户端证书的持有者。

##### ChangeCipherSpec【client->server】

ChangeCipherSpec(准备切换密码)
ChangeCipherSpec是密码规格变更协议的消息，表示后面的消息将会以前面协商过的密钥进行加密。

##### finished【client->server】

finished(握手协议结束)
客户端告诉服务器端握手协议结束了。

##### ChangeCipherSpec【server->client】

ChangeCipherSpec(准备切换密码)
服务器端告诉客户端自己要切换密码了。

##### finished【server->client】

finished(握手协议结束)
服务器端告诉客户端，握手协议结束了。
切换到应用数据协议
这之后服务器和客户端就是以加密的方式进行沟通了。

##### 切换到应用数据协议

这之后服务器和客户端就是以加密的方式进行沟通了。

主密码和预备主密码
上面的步骤8生成了预备主密码，主密码是根据密码套件中定义的单向散列函数实现的伪随机数生成器+预备主密码+客户端随机数+服务器端随机数生成的。

主密码主要用来生成称密码的密钥，消息认证码的密钥和对称密码的CBC模式所使用的初始化向量。详见[分组密码模式](http://www.flydean.com/block-cipher-mode/)

##### TLS记录协议

TLS记录协议主要负责消息的压缩，加密及数据的认证：
![image.png](/upload/computerselfeducationroad/image-1a4e3c6656394e579b5281d6beeb7506.png)

消息首先将会被分段，然后压缩，再计算其消息验证码，然后使用对称密码进行加密，加密使用的是CBC模式，CBC模式的初始向量是通过主密码来生成的。

得到密文之后会附加类型，版本和长度等其他信息，最终组成最后的报文数据。

### TCP连接和关闭过程

#### 三次挥手与原因

在TCP/IP协议中，TCP协议提供可靠的连接服务，采用三次握手建立一个连接。

##### 第一次握手

建立连接时，客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

SYN：同步序列编号（Synchronize Sequence Numbers）。是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN+ACK应答表示接收到了这个消息，最后客户机再以ACK消息响应。

这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。

##### 第二次握手

服务器收到syn包，必须确认客户的SYN（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

ACK (Acknowledge character）即是确认字符，在数据通信中，接收站发给发送站的一种传输类控制字符。表示发来的数据已确认接收无误。

在TCP/IP协议中，如果接收方成功的接收到数据，那么会回复一个ACK数据。通常ACK信号有自己固定的格式,长度大小,由接收方回复给发送方。

##### 第三次握手

客户端收到服务器的SYN＋ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。

第三次握手是为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误。

譬如发起请求遇到类似这样的情况：客户端发出去的第一个连接请求由于某些原因在网络节点中滞留了导致延迟，直到连接释放的某个时间点才到达服务端，这是一个早已失效的报文，但是此时服务端仍然认为这是客户端的建立连接请求第一次握手，于是服务端回应了客户端，第二次握手。

如果只有两次握手，那么到这里，连接就建立了，但是此时客户端并没有任何数据要发送，而服务端还在傻傻的等候佳音，造成很大的资源浪费。所以需要第三次握手，只有客户端再次回应一下，就可以避免这种情况。

![TCP三次握手](/upload/computerselfeducationroad/TCP-b0b17b3327a04435ba2508795764efa5.png)

#### 四次挥手与原因

##### 第一次挥手

Client发送一个FIN, 用来关闭Client 到 Server的数据传输, Client进入FIN_WAIT_1状态

##### 第二次挥手

Server收到FIN后, 发送一个ACK给Client, 确认序号为收到的序号+1(与SYN相同, 一个FIN占用一个序号),Server进入CLOSE_WAIT状态

##### 第三次挥手

Server发送一个FIN后, 用来关闭Server到Client的数据传输, Server进入LAST_ACK状态

##### 第四次挥手

Client收到FIN后, Client进入TIME_WAIT状态, 接着发送一个ACK给Server, 确认序号为收到序号+1, Server进入CLOSED状态, 完成四次挥手。

所谓四次挥手就是终止TCP连接, 就是要断开一个TCP连接时, 需要客户端和服务器总共进行四次交互。执行过程由客户端或者服务器任意一方执行close来触发。

由于TCP连接时全双工的, 因此, 每个方向都必须要单独进行关闭, 这一原则是当一方完成数据发送任务后, 发送一个FIN来终止这一方向的连接,收到一个FIN只是意味着这一方向上没有数据流动了, 即不会再收到数据了, 但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN. 首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。

四次挥手时，主动发起关闭连接的操作的一方将达到TIME_WAIT状态，而且这个状态要保持Maximum Segment Lifetime的两倍时间(2MSL)。

为什么不直接关闭要进入等待状态？

1.保证客户端发送的ACK报文段能够到达服务器，从而保证tcp连接能够进行可靠的关闭。

 这个很好理解，如果客户端发动ACK后就立刻关闭，那么如果ACK丢失的话，服务端就会一直处于等待关闭确认的状态，超时后再发送关闭请求时，此时的客户端已经关闭，那么服务端就无法进行正常的关闭。

2.保证此次连接的数据段消失，防止失效的数据段。

客户端在发送ACK后，再等待2MSL时间，可以使本次连接所产生的数据段从网络中消失，从而保证关闭连接后不会有还在网络中滞留的数据段去骚扰服务端；

再有一点就是，如果客户端重新发送请求，如果前一次连接的某些数据仍然滞留在网络中，这些延迟数据在建立新连接之后才到达Server，由于新连接和老连接的端口号是一样的，又因为TCP协议判断不同连接的依据是socket pair，于是，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发生混淆了。

为什么是2MSL?

我们知道服务端收到ACK，关闭连接。但是客户端无法知道ACK是否已经到达服务端，于是开始等待？等待什么呢？假如ACK没有到达服务端，服务端会为FIN这个消息超时重传 timeout retransmit ，那如果客户端等待时间足够，又收到FIN消息，说明ACK没有到达服务端，于是再发送ACK，直到在足够的时间内没有收到FIN，说明ACK成功到达。这个等待时间至少是：服务端的timeout + FIN的传输时间，为了保证可靠，采用更加保守的等待时间2MSL。

MSL，Maximum Segment Life，这是TCP 对TCP Segment 生存时间的限制。

客户端发出ACK，等待ACK到达对方的超时时间 MSL，等待FIN的超时重传，也是MSL，所以如果2MSL时间内没有收到FIN，说明对方安全收到FIN。

## 面试常问

### HTTP和HTTPS有什么区别？

- HTTPS使用的是对称加密还是非对称加密？

HTTPS 在内容传输的加密上使用的是对称加密，证书验证阶段是非对称加密。

- 简述一下HTTPS的加密过程，需要几次通信？

![image-1664159529056](/upload/computerselfeducationroad/image-1664159529056.png)
① 证书验证阶段：

1）浏览器发起 HTTPS 请求；

2）服务端返回 HTTPS 证书；

3）客户端验证证书是否合法，如果不合法则提示告警。

② 数据传输阶段：

1）当证书验证合法后，在本地生成随机数；

2）通过公钥加密随机数，并把加密后的随机数传输到服务端；

3）服务端通过私钥对随机数进行解密；

4）服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。

### cookie 和session的区别？

cookie 是存在本地的身份验证信息，session是存在服务器的验证信息。

- cookie 和 JWT的优势

cookie结构简单，持久保存不占用服务器资源

JSON Web Token由三部分组成，它们之间用圆点(.)连接。这三部分分别是：Header、Payload、Signature，可以在自身存储一些其他业务逻辑所必要的非敏感信息。

### 什么是同源策略，CORS如何实现？

如果两个 URL 的 protocol、port (en-US) (如果有指定的话) 和 host 都相同的话，则这两个 URL 是同源。

![image-1663124363912](/upload/computerselfeducationroad/image-1663124363912.png)

跨源资源共享标准新增了一组 HTTP 首部字段，允许服务器声明哪些源站通过浏览器有权限访问哪些资源。


### 为什么 MD5 不能用于存储密码

#### 为什么要加密

很多软件工程师都认为 MD5 是一种加密算法，然而这种观点其实是大错特错并且十分危险的，作为一个 1992 年第一次被公开的算法，到今天为止已经被发现了一些致命的漏洞，我们在生产环境的任何场景都不应该继续使用 MD5 算法，无论是对数据或者文件的内容进行校验还是用于所谓的『加密』。

与『为什么我们不能使用 MD5 来存储密码？』这一问题相似的其实还有『为什么我们不能使用明文来存储密码？』，使用明文来存储密码是一种看起来就不可行的方案，除非我们能够 100% 保证数据库中的密码字段不会被任何人访问到，不仅包括潜在的攻击者，还包括系统的开发者和管理员。

不过这是一个非常理想的情况，在实际的生产环境中，我们不能抵御来自黑客的所有攻击，甚至也不能完全阻挡开发者和管理员的访问，因为我们总需要信任并授权一些人或者程序具有当前数据库的所有访问权限，这也就给攻击者留下了可以利用的漏洞，在抵御外部攻击时我们没有办法做到全面，只能尽可能提高攻击者的成本，这也就是使用 MD5 或者其他方式存储密码的原因了。

![image.png](/upload/computerselfeducationroad/image-f58d94784c404ace81e37e42de5b9b88.png)

#### 为什么应该停止使用MD5加密

很多开发者对于 MD5 的作用和定义都有着非常大的误解，MD5 并不是一种加密算法，而是一种摘要算法，我们也可以叫它哈希函数，哈希函数可以将无限键值空间中的所有键都均匀地映射到一个指定大小的键值空间中；一个好的摘要算法能够帮助我们保证文件的完整性，避免攻击者的恶意篡改，但是加密算法或者加密的功能是 —— 通过某种特定的方式来编码消息或者信息，只有授权方可以访问原始数据，而没有被授权的人无法从密文中获取原文。

由于加密需要同时保证消息的秘密性和完整性，所以加密的过程使用一系列的算法，MD5 确实可以在加密的过程中作为哈希函数使用来保证消息的完整性，但是我们还需要另一个算法来保证消息的秘密性，所以由于 MD5 哈希的信息无法被还原，只依靠 MD5 是无法完成加密的。

在任何场景下，我们都应该避免 MD5 的使用，可以选择更好的摘要算法替代 MD5，例如 SHA256、SHA512。

聊了这么多对于 MD5 的误解，我们重新回到今天最开始的题目，『为什么 MD5 不能用于存储密码』，对于这个问题有一个最简单的答案，也就是 MD5 不够安全。当整个系统中的数据库被攻击者入侵之后，存储密码的摘要而不是明文是我们能够对所有用户的最大保护。需要知道的是，不够安全的不只是 MD5，任何摘要算法在存储密码这一场景下都不够安全，我们在这篇文章中就会哈希函数『为什么哈希函数不能用于存储密码』以及其他相关机制的安全性。

#### 对比分析

既然我们已经对哈希函数和加密算法有了一些简单的了解，接下来的这一节中分析使用以下几种不同方式存储密码的安全性：

- 使用哈希存储密码；
- 使用哈希加盐存储密码；
- 使用加密算法存储密码；
- 使用 bcrypt 存储密码；

在分析的过程中可能会涉及到一些简单的密码学知识，也会谈到一些密码学历史上的一些事件，不过这对于理解不同方式的安全性不会造成太大的障碍。

##### 哈希

在今天，如果我们直接使用哈希来存储密码，那其实跟存储明文没有太多的区别，所有的攻击者在今天都已经掌握了彩虹表这个工具，我们可以将彩虹表理解成一张预计算的大表，其中存储着一些常见密码的哈希，当攻击者通过入侵拿到某些网站的数据库之后就可以通过预计算表中存储的映射来查找原始密码。

![image.png](/upload/computerselfeducationroad/image-c1f4173ac79a4818a85d48437ba4da03.png)

攻击者只需要将一些常见密码提前计算一些哈希就可以找到数据库中很多用于存储的密码，Wikipedia 上有一份关于最常见密码的 列表，在 2016 年的统计中发现使用情况最多的前 25 个密码占了调查总数的 10%，虽然这不能排除统计本身的不准确因素，但是也足以说明仅仅使用哈希的方式存储密码是不够安全的。

##### 哈希加盐

仅仅使用哈希来存储密码无法抵御来自彩虹表的攻击，在上世纪 70 到 80 年代，早期版本的 Unix 系统就在 /etc/passwrd 中存储加盐的哈希密码，密码加盐后的哈希与盐会被一起存储在 /etc/passwd 文件中，今天哈希加盐的策略与几十年前的也没有太多的不同，差异可能在于盐的生成和选择：

md5(salt, password), salt
加盐的方式主要还是为了增加攻击者的计算成本，当攻击者顺利拿到数据库中的数据时，由于每个密码都使用了随机的盐进行哈希，所以预先计算的彩虹表就没有办法立刻破译出哈希之前的原始数据，攻击者对每一个哈希都需要单独进行计算，这样能够增加了攻击者的成本，减少原始密码被大范围破译的可能性。

![image.png](/upload/computerselfeducationroad/image-5faf1b48e02045f38b2a77d462a58037.png)

在这种情况下，攻击者破解一个用户密码的成本其实就等于发现哈希碰撞的概率，因为攻击者其实不需要知道用户的密码是什么，他只需要找到一个值 value，这个值加盐后的哈希与密码加盐后的哈希完全一致就能登录用户的账号：

```language
hash(salt, value) = hash(salt, password)
```

这种情况在密码学中叫做哈希碰撞，也就是两个不同值对应哈希相同，一个哈希函数或者摘要算法被找到哈希碰撞的概率决定了该算法的安全性，早在几十年前，我们就在 MD5 的设计中发现了缺陷并且在随后的发展中找到了低成本快速制造哈希碰撞的方法。

```language
1996 年 The Status of MD5 After a Recent Attack —— 发现了 MD5 设计中的缺陷，但是并没有被认为是致命的缺点，密码学专家开始推荐使用其他的摘要算法；
2004 年 How to Break MD5 and Other Hash Functions —— 发现了 MD5 摘要算法不能抵抗哈希碰撞，我们不能在数字安全领域使用 MD5 算法；
2006 年 A Study of the MD5 Attacks: Insights and Improvements —— 创建一组具有相同 MD5 摘要的文件；
2008 年 MD5 considered harmful today —— 创建伪造的 SSL 证书；
2010 年 MD5 vulnerable to collision attacks —— CMU 软件工程机构认为 MD5 摘要算法已经在密码学上被破译并且不适合使用;
2012 年 Flame —— 恶意软件利用了 MD5 的漏洞并伪造了微软的数字签名；
```

从过往的历史来看，为了保证用户敏感信息的安全，我们不应该使用 MD5 加盐的方式来存储用户的密码，那么我们是否可以使用更加安全的摘要算法呢？不可以，哈希函数并不是专门用来设计存储用户密码的，所以它的计算可能相对来说还是比较快，攻击者今天可以通过 GPU 每秒执行上亿次的计算来破解用户的密码，所以不能使用这种方式存储用户的密码，感兴趣的读者可以了解一下用于恢复密码的工具 Hashcat。

##### 加密

既然今天的硬件已经能够很快地帮助攻击者破解用户的密码，那么我们能否通过其他的方式来取代哈希函数来存储密码呢？有些工程师想到使用加密算法来替代哈希函数，这样能够从源头上避免哈希碰撞的发生，这种方式看起来非常美好，但是有一个致命的缺点，就是我们如何存储用于加密密码的秘钥。

既然存储密码的仓库能被泄露，那么用于存储秘钥的服务也可能会被攻击，我们永远都没有办法保证我们的数据库和服务器是安全的，一旦秘钥被攻击者获取，他们就可以轻而易举地恢复用户的密码，因为核对用户密码的过程需要在内存对密码进行解密，这时明文的密码就可能暴露在内存中，依然有导致用户密码泄露的风险。

![image.png](/upload/computerselfeducationroad/image-94d7e25774624fe4883aec2990e92d1d.png)

使用加密的方式存储密码相比于哈希加盐的方式，在一些安全意识和能力较差的公司和网站反而更容易导致密码的泄露和安全事故。

##### bcrypt

哈希加盐的方式确实能够增加攻击者的成本，但是今天来看还远远不够，我们需要一种更加安全的方式来存储用户的密码，这也就是今天被广泛使用的 bcrypt，使用 bcrypt 相比于直接使用哈希加盐是一种更加安全的方式，也是我们目前推荐使用的方法，为了增加攻击者的成本，bcrypt 引入了计算成本这一可以调节的参数，能够调节执行 bcrypt 函数的成本。

![image.png](/upload/computerselfeducationroad/image-90dee258e09142c6af4e98a4263a11b3.png)

当我们将验证用户密码的成本提高几个数量级时，攻击者的成本其实也相应的提升了几个数量级，只要我们让攻击者的攻击成本大于硬件的限制，同时保证正常请求的耗时在合理范围内，我们就能够保证用户密码的相对安全。

bcrypt 这一算法就是为哈希密码而专门设计的，所以它是一个执行相对较慢的算法，这也就能够减少攻击者每秒能够处理的密码数量，从而避免攻击者的字典攻击。

```Go
# Go
func main() {
	for cost := 10; cost <= 15; cost++ {
		startedAt := time.Now()
		bcrypt.GenerateFromPassword([]byte("password"), cost)
		duration := time.Since(startedAt)
		fmt.Printf("cost: %d, duration: %v\n", cost, duration)
	}
}

$ go run bcrypt.go
cost: 10, duration: 51.483401ms
cost: 11, duration: 100.639251ms
cost: 12, duration: 202.788492ms
cost: 13, duration: 399.552731ms
cost: 14, duration: 801.041128ms
cost: 15, duration: 1.579692689s
```

运行上述 代码片段 时就能发现 cost 和运行时间的关系，算法运行的成本每 +1，当前算法最终的耗时就会翻一倍，这与 bcrypt 算法的实现原理有关，你可以在 Wikipedia 上找到算法执行过程的伪代码，这可以帮助我们快速理解算法背后的设计。

如果硬件的发展使攻击者能够对使用 bcrypt 存储的密码进行攻击时，我们就可以直接提升 bcrypt 算法的 cost 参数以增加攻击者的成本，这也是 bcrypt 设计上的精妙之处，所以使用 bcrypt 是一种在存储用户密码时比较安全的方式。

当数据库被攻击者获取时，我们怎么能够保证用户的密码很难被攻击者『破译』，作为保护用户机密信息的最后手段，选择安全并且合适的方法至关重要。攻击者能否破解用户的密码一般取决于两个条件：

- 使用的加密算法是否足够安全，使用暴力破解的方式时间成本极高；
- 足够好的硬件支持，能够支持大规模地高速计算哈希；

抵御攻击者的攻击的方式其实就是提高单次算法运行的成本，当我们将用户的验证耗时从 0.1ms 提升到了 500ms，攻击者的计算成本也就提升了 5000 倍，这种结果就是之前需要几小时破解的密码现在需要几年的时间。

不论如何，使用 MD5、MD5 加盐或者其他哈希的方式来存储密码都是不安全的，希望各位工程师能够避免在这样的场景下使用 MD5，在其他必须使用哈希函数的场景下也建议使用其他算法代替，例如 SHA-512 等。

当然，如何保证用户机密信息的安全不只是一个密码学问题，它还是一个工程问题，任何工程开发商的疏漏都可能导致安全事故，所以我们作为开发者在与用于敏感信息打交道时也应该小心谨慎、怀有敬畏之心。到最后，我们还是来看一些比较开放的相关问题，有兴趣的读者可以仔细思考一下下面的问题：

- 使用 GPU 每秒可以计算多少 MD5 哈希（数量级）？能够在多长时间破解使用 MD5 加盐存储的密码？
- 假设计算一次哈希耗时 500ms，破解 bcrypt 算法生成的哈希需要多长时间？
- MD5 哈希 23cdc18507b52418db7740cbb5543e54 对应的原文可能是？谈谈你使用的工具和破译的过程。
